<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/render-status.html">
<link rel="import" href="../../bower_components/lazy-imports/lazy-imports-mixin.html">

<dom-module id="ydc-app">
  <!--  <link  rel="lazy-import" group="lazy"  href="../ydc-pad/ydc-pad.html">
  <link  rel="lazy-import" group="lazy"  href="../ydc-palette/ydc-palette.html">
  <link  rel="lazy-import" group="lazy"  href="../ydc-pinceau/ydc-pinceau.html">
  <link  rel="lazy-import" group="lazy"  href="../ydc-menu/ydc-menu.html">
  <link rel="lazy-import" group="lazy" href="../../bower_components/valle-speed-dial/valle-speed-dial.html">
  <link rel="lazy-import" group="lazy" href="../../bower_components/valle-speed-dial/valle-speed-dial-action.html">
-->
<link rel="lazy-import" group="lazy"  href="../../bower_components/color-picker/color-picker.html">
<link rel="lazy-import" group="lazy"  href="../../bower_components/color-picker/color-element.html">
<template>
  <style>
  :host {
    display: block;

  }
  /* minimal reset */
  * {
    margin: 0;
    padding: 0;
  }

  /* page styles */
  body {
    background: #ddd;
    font-family: sans-serif;
  }

  @media screen and (max-height: 650px) {
    #sizetoolbar {
      display: none;
    }
  }

  @media screen and (max-height: 600px) {
    #colortoolbar {
      display: none;
    }
  }

  button {
    border: none;
    background: #aaa;
    width: 45px;
    height: 45px;
    border-radius: 30px;
    margin: 2px;
  }

  #container {
    width: 800px;
    margin: 1em auto 0;
  }

  #scratchpad {
    background: #eee;
    box-shadow: 0 0 20px #ccc;
    cursor: default;
    /*  width: 90vw;*/
  }

  #footer {
    margin-top: 1em;
    font-size: .6em;
    color: #888;
    text-align: center;
  }

  #footer a {
    color: #444;
  }
  #dialsize{
    position: fixed;
    left: 15px;
    bottom: 15px;
    /*--valle-speed-dial-action-fab-color: #d4f442;*/
    --valle-speed-dial-backdrop-color: rgba(55, 55, 255, 0.5) ; /* rgba(200, 200, 10, 0.2), */
  }
  #dialsize-action .label {
    display: inline-block;
    left: -158px;
  }
  #colorpicker {
    position: fixed;
    left: 15px;
    top: 15px;
    --color-element-badge-radius: --input-picker-border-radius, 10px
  }
  </style>
  <div id="container">
    <!--  <aside class="toolbar" id="colortoolbar">-->

  </aside>
  <div id="main">
    <canvas id="scratchpad"  width="800" height="500"></canvas>
  </div>
  <aside class="toolbar" id="sizetoolbar">
    <a href="#" id="download" download="image.png"><button align="center">Save</button></a>

  </aside>

  <footer id="footer">
    Utilisateurs connectés : <span id="counter">?</span> &middot;
    Made by <a href="https://mrozwadowski.com/">MR</a> &middot;
    Fork me on <a href="https://github.com/hejmsdz/sketchpad">GitHub</a>
    Forked by scenaristeur at <a href="https://github.com/scenaristeur/lininoapps/tree/master/root/ydc">Scenaristeur/sketchpad</a>
  </footer>
</div>
<!--  <ydc-canvas></ydc-canvas>
<ydc-palette></ydc-palette>
<ydc-pinceau></ydc-pinceau>
<ydc-menu></ydc-menu>-->
<!--<valle-speed-dial id="dialsize" direction="top" label="Menu" backdrop >
<valle-speed-dial-action
class="dial-action"
label="Réglages"
on-tap="_toggleSettings"
label-direction="right"
></valle-speed-dial-action>
<valle-speed-dial-action
class="dial-action"
label="Mode"
on-tap="_toggleMode"
label-direction="right"
></valle-speed-dial-action>
<valle-speed-dial-action
class="dial-action"
on-tap="_toggleHelp"
label="Aide"
label-direction="right"
></valle-speed-dial-action>
</valle-speed-dial> -->


<color-picker
id="colorpicker"
autoconfirm
value="{{color}}">
</color-picker>
<!--    native -->
</template>
<script src="/socket.io/socket.io.js"></script>
<!--<script src="js/main.js"></script> -->
<script>
/**
* @customElement
* @polymer
*/
class YdcApp extends Polymer.LazyImportsMixin(Polymer.Element) {
  static get is() { return 'ydc-app'; }
  static get properties() {
    return {
      canvas: {
        type: Object
      },
      socket: {
        type: Object
      },
      sizeToolbar: {
        type: Object
      },
      colorToolbar: {
        type: Object
      },
      counter: {
        type: Number
      },
      color: {
        type: Object,
        value: '#000000'
      },
      snapshotLines: {
        type: Array,
        value: []
      },
      tickDelay: {
        type: Number,
        value: 1000
      }
    };
  }
  constructor(){
    super();
    Polymer.RenderStatus.afterNextRender(this, function() {
      this._deferred();
    });
  }
  _deferred(){
    this.importLazyGroup('lazy').then((results) => {
      this.dispatchEvent(new CustomEvent('import-loaded', results));
    });
    var app = this;
    this.canvas = this.$.scratchpad;
    this.socket = io();
    this.sizeToolbar = this.$.sizetoolbar;
    this.colorToolbar = this.$.colortoolbar;
    this.counter = this.$.counter;
    var ctx = this.canvas.getContext('2d');
    var oldPos = {};
    var size = 4;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    // populate the toolbars
    for (var i=1; i<10; i++) {
      var lineSize = Math.round(i*2);
      var el = document.createElement('button');
      el.innerHTML = lineSize;
      el.dataset.size = lineSize;
      el.addEventListener('click', function() {
        size = this.dataset.size;
      });
      this.sizeToolbar.appendChild(el);
    }
    /*
    var colors = [];
    for (var i=0; i<10; i++) {
    colors.push('hsl('+(36*i-6)+', 93%, 47%)');
  }
  colors.push('#eee', '#222');
  for (var i=0; i<colors.length; i++) {
  var el = document.createElement('button');
  el.dataset.color = colors[i];
  el.style.background = colors[i];
  el.addEventListener('click', function() {
  console.log(this.dataset.color)
  app.set('color',hsl(this.dataset.color));
  console.log(app.color)
});
this.colorToolbar.appendChild(el);
}*/


function eventToXY(e) {
  return {
    x: e.offsetX || e.layerX || e.clientX - app.canvas.offsetLeft,
    y: e.offsetY || e.layerY || e.clientY - app.canvas.offsetTop
  };
}

function line(start, end, size, color) {
  var oldSize = ctx.lineWidth;
  var oldColor = ctx.fillStyle;

  ctx.lineWidth = size;
  ctx.strokeStyle = color;

  ctx.beginPath();
  ctx.moveTo(start.x, start.y);
  ctx.lineTo(end.x, end.y);
  ctx.stroke();
  ctx.closePath();

  ctx.lineWidth = oldSize;
  ctx.strokeStyle = oldColor;
}

function handleStart(e) {
  oldPos = eventToXY(e);
  handleMove(e); // draw a single point
}

function handleMove(e) {
  var newPos = eventToXY(e);
  var data = {start: oldPos, end: newPos, size: size, color: app.color};
  app.sendLines(data);
  line(oldPos, newPos, size, app.color);
  oldPos = newPos;
};

function handleEnd(e) {
  oldPos = {};
}

app.canvas.addEventListener('mousedown', function(e) {
  if (e.which == 1) {
    handleStart(e);
  }
});

app.canvas.addEventListener('mousemove', function(e) {
  e.preventDefault();
  if (e.buttons & 1) {
    handleMove(e);
  }
});

app.canvas.addEventListener('mouseout', handleEnd);

app.canvas.addEventListener('touchstart', function(e) {
  var touches = e.touches;
  if (touches.length == 1) {
    handleStart(touches[0]);
  }
});

app.canvas.addEventListener('touchmove', function(e) {
  e.preventDefault();
  var touches = e.touches;
  if (touches.length == 1) {
    //  console.log(eventToXY(touches[0]));
    handleMove(touches[0]);
  }
});

app.canvas.addEventListener('touchend', handleEnd);

// remote events
app.socket.on('num_clients', function(infos_clients) {
  //  console.log(infos_clients)
  //  app.tickDelay = infos_clients.tickDelay;
  //  console.log(app.tickDelay)
  app.set('typeSync', infos_clients.typeSync)
  if(app.typeSync == 'async'){
    app.launchAsync(infos_clients.tickDelay);
  }else{
    if(app.snapshotLines.length >0){
      console.log("tock");
      app.io.emit('snapshotLines', app.snapshotLines);
      app.snapshotLines = new Array();
    }
    clearInterval(app.tickInterval);
  }
  app.counter.innerHTML = infos_clients.num_clients + " : " +app.typeSync;
});
// mode sync
app.socket.on('line', function(data) {
  line(data.start, data.end, data.size, data.color);
});
//mode async
app.socket.on('tick', function(data){
  //  console.log(data);
  //  console.log(data.lines);
  let lines = data.lines;
  lines.forEach(function(l){
    line(l.start, l.end, l.size, l.color);
  });
});

app.socket.on('screenshot', function() {
app.screenshot();
});

app.socket.on('lastScreenshot', function(strDataURI){
//  console.log(strDataURI)
  var ctx = app.canvas.getContext('2d');
  var img = new Image;
  img.onload = function(){
    ctx.drawImage(img,0,0); // Or at whatever offset you like
  };
  img.src = strDataURI;
})

app.socket.on('disconnect', function() {
app.screenshot();
});

/*window.onbeforeunload = function(e) {
//  app.screenshot();
    return('Please press the Logout button to logout.') ;
}*/

window.onbeforeunload = function(){
  app.screenshot();
  return 'Are you sure you want to leave?';
};


// download
const download = this.$.download;
const rand = i=>Math.random()*i<<0;
const fileName = `image${100+rand(100)}.png`;

function onClickAnchor(e) {
  app.canvas.style.backgroundColor = 'rgba(158, 167, 184)';
  var screenshot;
  if (window.navigator.msSaveBlob) {
    screenshot = app.canvas.msToBlob()
    window.navigator.msSaveBlob(screenshot, fileName);
    e.preventDefault();
  } else {
    screenshot = app.canvas.toDataURL();
    download.setAttribute('download', fileName);
    download.setAttribute('href', screenshot);
  }
    app.socket.emit('screenshot', screenshot);
}

download.addEventListener('click', onClickAnchor);


}

launchAsync(tickDelay){
  var app = this;
  tickDelay = tickDelay + Math.floor(Math.random() * tickDelay ); // DEcalage pour que tous les clients n'envoie pas en même temps

  //async
  app.tickInterval = setInterval(function() {
    //A intervalles réguliers, on envoie à tout utilisateur connecté, un snapshot des dernières modifications et on réinitialise les lines stockées dans le snapshot
    //  console.log("tick");
    //  console.log(snapshot);
    if(app.snapshotLines.length >0){
      //  console.log("tock");
      app.sendSnaphotLines();
    }
  }, tickDelay);
}

sendLines(data){
  if (this.typeSync == "sync"){
    this.socket.emit('line', data);
  }else{
    this.push('snapshotLines', data);
    //    console.log(this.snapshotLines)
  }
}
sendSnaphotLines(){
  this.socket.emit('snapshotLines', this.snapshotLines);
  //socket.broadcast.emit('tick', snapshot);
  this.snapshotLines = new Array();
}

screenshot(){
  console.log("SCREENSHOT PLEASE")
  var screenshot;
  if (window.navigator.msSaveBlob) {
    screenshot = window.navigator.msSaveBlob(this.canvas.msToBlob(), fileName);
  } else {
    screenshot =  this.canvas.toDataURL();
  }
//  console.log(screenshot)
  this.socket.emit('screenshot', screenshot);
}




}

window.customElements.define(YdcApp.is, YdcApp);
</script>
</dom-module>
